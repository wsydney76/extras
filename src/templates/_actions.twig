{#
Call Craft web controller actions from JavaScript and display success/error notices

Usage:

Template:
{% include '@extras/_actions.twig' with {...} only %}

JavaScript:

Signature
window.Actions.postAction(action, data, callback, handleFailures = true, timeout = 10000), where
- action is the route to the Craft web controller, e.g. mymodule/mycontroller/myaction,
- data is an object with the parameters passed to the server as body params, e.g. {'id': 1234, 'newTitle': 'My New Title'}
- callback is a closure that will handle the response, unused arguments can be omitted.
  - () => {...}
  - data => {...}
  - (data, status, ok) => {...}
- handleFailures can be set to false, if you want to handle '400' responses in the callback
- timeout is the number of milliseconds after which a request will be aborted. Set to '0' if the request should never timeout.

Signature of the callback: (data, status, ok), where
- data is the decoded json response,
  - data.message will hold the message returned via ->asSuccess('message'), ->asFailure('message')
  - data.<key> will hold additional data returned
  - data.<modelName> will hold model data return via ->asModelSuccess(), ->asModelFailure()
  - data.errors will hold validation errors for a model returned via ->asModelFailure()
- status is the http status code, (200, 400, etc),
- ok is a boolean, indicating whether the request was successful or not.


By default, the callback will only be called if the server responds with a status code "200",
so that you don't have to care about any errors in your client code.

Errors will be logged to console and displayed via an error notice:
- Controller runtime errors
- Connection failure (server not running)
- Non-existing controller actions
- Uncaught exceptions thrown in controller action
- Failed 'require...' constraints (like $this->requireAdmin())
- Timed out requests
- Non-JSON responses (that should never happen...)
- Responses with status code 400, like failed controller actions (return $this->asFailure(...)), if handleFailures = true (default)

Example:

    Controller:
    actionMyaction: return $this->asSuccess('Done');

    window.Actions.postAction("mymodule/mycontroller/myaction",
        {'id': 1234, ...},
        data => {
            // do something
            notice({type: 'success', text: data.message});
        }
    );


Example: Handling failures in callback

    Controller:

    if(...failed...) {
        return $this->asFailure('Something went wrong.');
    }
    ...
    return $this->asSuccess('Done');


    window.Actions.postAction("mymodule/mycontroller/myaction",
        {'id': 1234, ...},

        (data, status, ok) => {
            if (status === 200) {
                 ...
                notice({type: 'success', text: data.message);
            } else {
                ...
                notice({type: 'error', text: data.message});
            }
        }, false)


Example with additional data:

    Controller:
    return $this->asSuccess(
            'This is a success with data.',
            [
                'foo' => 'bar',
                'baz' => 'qux',
            ]
        );

    Actions.postAction("mymodule/mycontroller/myaction",
        {'id': 1234},
        data => {
            alert(data.message + ': Foo=' + data.foo);
        });

Note:
For simplicity and having just one file, all JS/HTML/CSS is included directly in each page's source code.

If you want to include parts in your own asset bundle or modify them, disable the corresponding part.

Consider including this template only on pages where it is needed.

{% do _globals.set('requireActions', true) %}

...

{% if _globals.get('requireActions') %}
    {% include '@extras/_actions.twig' with {} only %}
{% endif %}
#}

{% set baseUrl = baseUrl ?? parseEnv('$PRIMARY_SITE_URL') %}
{% set enableNotices = enableNotices is defined ? enableNotices : true %}
{% set enableClasses = enableClasses is defined ? enableClasses : true %}
{% set enableFetchJs = enableFetchJs is defined ? enableFetchJs : true %}
{% set enableNoticesJs = enableNoticesJs is defined ? enableNoticesJs : true %}
{% set enableNoticesHtml = enableNoticesHtml is defined ? enableNoticesHtml : true %}

{# ======================================================================= #}
{# Set params required for sending ajax (post) requests to web controllers #}
{# ======================================================================= #}

{% js %}
window.baseUrl = "{{ baseUrl }}"
window.actionTrigger = "{{ craft.app.config.general.actionTrigger }}";
window.csrfTokenName = "{{ craft.app.config.general.csrfTokenName }}";
window.csrfTokenValue = "{{ craft.app.request.csrfToken }}";
{% endjs %}

{# ======================================================================= #}
{# Fetch response Craft web controller actions                             #}
{# ======================================================================= #}

{% if enableFetchJs %}
    {% js %}

    // Namespace functions
    window.Actions = window.Actions || {};

    // Function to post an action to the Craft web controller
    window.Actions.postAction = function(action, data, callback, handleFailures = true, timeout = 10000) {

        // Create an AbortController to handle request timeouts
        const abortController = new AbortController();
        let timeoutId;
        if (timeout > 0) {
            // Set a timeout to abort the request if it takes too long
            timeoutId = setTimeout(() => abortController.abort(), timeout);
        }

        // Make the fetch request to the specified action
        fetch(window.baseUrl + '/' + window.actionTrigger + '/' + action, {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'X-Csrf-Token': window.csrfTokenValue
            },
            body: JSON.stringify(data),
            signal: abortController.signal
        })
            .then((response) => {
                if (timeout > 0) {
                    // Clear the timeout if the request completes in time
                    clearTimeout(timeoutId);
                }
                return response.json()
                    .then((json) => ({
                        status: response.status,
                        ok: response.ok,
                        json
                    }));
            })
            .then(({status, json, ok}) => {
                const message = json.message;
                switch (status) {
                    case 200:
                    case 201:
                        // Call the callback function for successful responses
                        callback(json, status, ok);
                        break;

                    case 400:
                        if (handleFailures) {
                            // Throw an error for 400 responses if handleFailures is true
                            throw new Error(message)
                        }

                        // Call the callback function for 400 responses if handleFailures is false
                        callback(json, status, ok);

                        break;

                    default:
                        // Log and throw an error for other response statuses
                        console.log(status, json);
                        throw new Error(status + ' - ' + message);
                }
            })
            .catch(function(error) {
                console.log('Error caught:', error);

                let errorText = error.message;

                // Provide better error messages for specific error types
                if (error.name === 'AbortError') {
                    errorText = 'Request timed out.';
                } else if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    errorText = 'Could not connect to server.'
                }

                // Display the error notice or alert
                typeof Actions.notice === 'function' ? Actions.notice({type: 'error', text: errorText}) : alert(errorText)
            });
    }

    // Actions.notice({type:'success', text: 'It worked')
    // Type: one of success|info|warning|error
    // In AlpineJS `$dispatch('actions.notice', data)` can be used
    window.Actions.notice = function(data) {
        window.dispatchEvent(new CustomEvent('actions.notice', {detail: data}));
    }

    {% endjs %}
{% endif %}

{# ======================================================================= #}
{# Show notices via NoticesHandler class                                   #}
{# ======================================================================= #}

{% if enableNoticesJs %}
    {% js %}

    class NoticesHandler {
        constructor(params = {}) {
            const {timeout = 4000, classes = {}, wrapperId = 'notices-wrapper'} = params;
            this.notices = [];
            this.visible = [];
            this.noticeWrapper = document.getElementById(wrapperId); // Wrapper element for notices
            this.timeout = timeout;
            this.classes = {
                wrapper: 'notices-wrapper',
                position: 'notices-position',
                item: 'notices-item',
                success: 'notice-success',
                info: 'notice-info',
                warning: 'notice-warning',
                error: 'notice-error',
                ...classes
            };
            this.init();
        }

        // Initialize the notice handler
        init() {
            // Add global event listener for custom "notice" events
            window.addEventListener('actions.notice', (event) => this.add(event.detail));
            this.noticeWrapper.classList.add(this.classes.wrapper, this.classes.position);
        }

        // Add a new notice
        add(notice) {
            notice.id = Date.now(); // Unique ID for each notice
            this.notices.push(notice); // Add to notices array
            this.fire(notice.id); // Make notice visible
        }

        // Show the notice
        fire(id) {
            const notice = this.notices.find(notice => notice.id === id);
            if (notice) {
                this.visible.push(notice); // Add to visible array
                this.render(); // Update DOM with new notice

                // Remove the notice after a delay
                const timeShown = this.timeout * this.visible.length;
                setTimeout(() => {
                    this.remove(id);
                }, timeShown);
            }
        }

        // Remove a notice
        remove(id) {
            const index = this.visible.findIndex(notice => notice.id === id);
            if (index > -1) {
                this.visible.splice(index, 1); // Remove from visible array
                this.render(); // Update DOM after removal
            }
        }

        // Render notices to the DOM
        render() {
            // Clear existing notices in the DOM
            this.noticeWrapper.innerHTML = '';

            // Iterate over visible notices and create the necessary DOM elements
            this.visible.forEach(notice => {
                const noticeDiv = document.createElement('div');
                noticeDiv.classList.add(this.classes.item);

                noticeDiv.textContent = notice.text; // Set the text of the notice

                // Add appropriate class based on the type of notice
                const noticeClass = this.classes[notice.type] || this.classes.error;
                noticeDiv.classList.add(noticeClass);

                // Add click event to remove the notice when clicked
                noticeDiv.addEventListener('click', () => this.remove(notice.id));


                // stack on top
                // this.noticeWrapper.insertBefore(noticeDiv, this.noticeWrapper.firstChild);

                // Append notice
                this.noticeWrapper.appendChild(noticeDiv);

            });
        }
    }

    {% endjs %}
{% endif %}

{% if enableNoticesHtml %}
    {% js %}
    // Initialize the notice handler
    const noticesHandler = new NoticesHandler();
    {% endjs %}

    <div id="notices-wrapper"></div>
{% endif %}

{# ======================================================================= #}
{# Classes for notices                                                     #}
{# ======================================================================= #}

{% if enableClasses %}
    {% css %}
    .notices-wrapper {
        pointer-events: none;
        position: fixed;
        inset: 0;
        z-index: 9999;
        display: flex;
        height: 100vh;
        width: 100vw;
        flex-direction: column;
    }

    .notices-position {
        align-items: center; /* self-start, self-end for left/right */
        justify-content: flex-start; /* flex-end for bottom */
    }

    .notices-item {
        pointer-events: auto;
        cursor: pointer;
        z-index: 9999;
        margin: 0.5rem;
        display: flex;
        width: 24rem;
        align-items: center;
        justify-content: center;
        border-radius: 0.5rem;
        padding: 0.5rem 2rem;
        font-size: 0.875rem;
        line-height: 1.25rem;
        box-shadow: 4px 4px 16px -6px rgba(0, 0, 0, 0.5);
    }

    .notice-success {
        background-color: #16a34a; /* green-600 */
        color: white;
    }

    .notice-error {
        background-color: #dc2626; /* red-600 */
        color: white;
    }

    .notice-info {
        background-color: #2563eb; /* blue-600 */
        color: white;
    }

    .notice-warning {
        background-color: #ea580c; /* orange-600 */
        color: white;
    }
    {% endcss %}
{% endif %}

{# For fetch logic see: https://stackoverflow.com/questions/40248231/how-to-handle-http-code-4xx-responses-in-fetch-api #}
{# For notice component see: https://codepen.io/KevinBatdorf/pen/JjGKbMa?css-preprocessor=none, converted to vanilla JavaScript #}